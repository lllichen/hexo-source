---
title: dp
date: 2019-01-02 16:31:55
tags: dp
---


### dp处理原则
1. 动态规划可以在给定约束条件下找到最优解。
2. 问题可分解为彼此独立且离散的子问题


### 解决dp思路
1. 表格中的值代表什么
2. 如何分解子问题
3. 如何确定坐标轴


#### 最长递增子序列解法：
递推公式
1. dp[i] = max(dp[i],d[ 0 ~ i-1]+1); 时间复杂度  $O(n^2)$
```math
O(n^2)
```
空间复杂度 O（n)

2. 利用二分查找定位子序列最后值位置，时间复杂度O(n*logn)，空间复杂度 O(n)
3. bruce force,时间复杂度
```math
  O(2^n)
```
#### 背包问题:

cell[i][j] = max (上一个单元格的值, 当前商品价值+剩余空间的价值 ),即

```
cell[i][j] = max ( cell[i-1][j] , f(i) + cell[i-1][j-i] )

//注: f(i) 标识当前商品价值，j-i 表示剩余空间价值！
```


#### 最长公共子串

如果字母不同，则值为0，如果字母相同，则值为左上角值+1，伪代码如下：

```伪代码如下
if word_a[i] == word_b[j]:
    cell[i][j] = cell[i-1][j-1]+1;
else:
    cell[i][j] = 0;  
```

#### 最长公共子序列

如果两个字母不同，就选择上方和左方邻居中较大的那个，如果两个字母相同，就将当前单元格值设置为左上方单元格的值加1，伪代码如下：
```
if word_a[i] == word_b[j]:
    cell[i][j] = cell[i-1)[j-1]+1;
else:
    cell[i][j] = max(cell[i-1][j],cell[i][j-1]);
```