---
title: 分布式锁
date: 2018-09-12 12:04:56
tags: distribute lock
---

# 分布式锁

## 锁

锁解决的问题
当线程访问临界变量时，需要设置标记，保证线程访问的原子性和可见性
java中通常通过sychronize 关键字 和 Lock 类来实现 

## 分布式锁

分布式锁解决的是多进程访问临界资源的问题，即在分布式场景下，访问临界资源时，如何保证一致性。思路与
多线程访问一致，即设置一个可以访问的公共边量，阻塞进程，达到一致性，但分布式场景设计网络延时等场景，所以更复杂。

需要保证：

1. 安全性
2. 活性

## 利用 redis 构建分布式锁

redis 是单线程的，redis 的每个操作都是原子操作

redis 事务操作: MULTI EXEC DISCARD WATCH UNWATCH，
redis 事务有如下特性，即当redis 处理事务操作时，redis不会处理其他client端的命令。2.6之后引入luna脚本，一个luna脚本的执行是原子的。

简单分布式锁实现

``` 加锁
SET resource_name my_random_value NX PX 30000

解锁
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

该设计在单点情况下是有效的。存在这么一种情况，即master 创建key，slave 未同步master情况下，master 挂掉，slave 转为master，导致重复获取锁出现

对于分布式集群，redis官方给出了RedLock的算法，步骤如下：

 1. 获取当前Unix时间，以毫秒为单位。
 2. 依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。
 3. 客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。
 4. 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。
 5. 如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。

类似于选举算法，核心在于保证大部分节点（即至少n/2+1）能够存在锁，保证安全性，活性，貌似没有正式证明。

## zookeeper 分布式锁

## db 分布式锁